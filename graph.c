#include <stdio.h>
//假设取10个节点，N=28
//定义无穷大为100000
#define N 20
int distance[N];//最短路径
int path[N];//上一节点
int is[N];//是否选用该节点,0位未选用
int start;
int destination[N][N] = {
        {0,     75,    10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000},
        {55,    0,     15,    10000, 100,   10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000},
        {10000, 45,    0,     75,    15,    10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000},
        {10000, 10000, 75,    0,     10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000},
        {10000, 100,   35,    10000, 0,     110,   135,   10000, 10000, 10000, 10000, 10000, 10000, 75,    10000, 10000, 10000, 10000, 10000, 10000},
        {10000, 10000, 10000, 10000, 110,   0,     10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000},
        {10000, 10000, 10000, 10000, 225,   10000, 0,     65,    10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000},
        {10000, 10000, 10000, 10000, 10000, 10000, 125,   0,     45,    10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 45},
        {10000, 10000, 10000, 10000, 10000, 10000, 35,    75,    0,     45,    35,    10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000},
        {10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 55,    0,     35,    10000, 10000, 45,    10000, 10000, 10000, 10000, 10000, 10000},
        {10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 35,    25,    0,     25,    10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000},
        {10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 25,    0,     25,    10000, 10000, 10000, 10000, 10000, 10000, 10000},
        {10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 25,    0,     25,    15,    10000, 10000, 10000, 10000, 10000},
        {10000, 10000, 10000, 75,    10000, 10000, 10000, 10000, 10000, 45,    10000, 10000, 45,    0,     10000, 10000, 10000, 10000, 10000, 10000},
        {10000, 10000, 25,    10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 25,    10000, 0,     15,    15,    10000, 10000, 10000},
        {10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 25,    0,     15,    10000, 10000, 10000},
        {10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 15,    15,    0,     15,    10000, 10000},
        {10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 35,    0,     55,    10000},
        {10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 55,    0,     10000},
        {10000, 10000, 10000, 10000, 10000, 10000, 10000, 45,    10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 0}

};//路程矩阵
char name[20][15] = {"Lisbon", "Madrid", "Bern", "Rome", "Pairs", "London", "Brussels", "Amsterdam", "Berlin", "Prague",
                     "Warsaw", "Bucharest", "Budapest", "Vienna", "Sarajevo", "Sofia", "Skopja", "Tirane", "Athens",
                     "Copenhagen"
};

//find函数寻找最短路径
void find() {
    //最多进行N-1次循环
    for (int k = 1; k < N; k++) {
        double max = 10000;//路径最大值
        int u = 0;//u为已经找到最短路径的节点,初始状态都为起点0
        for (int i = 0; i < N; i++) {
            if (is[i] == 0 && distance[i] <= max) {
                u = i;
                max = distance[i];
            }
        }
        is[u] = 1;
        //找出一点后更新其余点的最短路径
        for (int y = 0; y < N; y++) {
            if (is[y] == 0 && distance[u] + destination[u][y] < distance[y]) {
                distance[y] = distance[u] + destination[u][y];
                path[y] = u;
            }
        }
    }
}

//输出最短路径
void showpath() {
    int count = 1, count1 = 1;
    if (start == 0) {
        printf("Lisbon<-Lisbon价格为: 0\n");
    }
    for (int i = 1; i < N; i++) {
        if (is[i] == 1) {
            int k = i;

            //输出到第一个结点
            if (start != 0 && start != 1) {
                if (count == 1) {
                    while (k != -1) {
                        printf("Lisbon<-%s<-", name[k]);
                        k = path[k];
                    }//若前一节点不为起点则不断查询前一节点
                    printf("%s 价格为: %d", name[start], distance[i]);
                    printf("\n");
                    count++;
                }
            }
            if (start == 1 && count1 == 1) {
                printf("Lisbon<-");
                printf("Madrid 价格为: 55");
                printf("\n");
                count1++;
            }

            k = i;
            while (k != -1) {
                printf("%s<-", name[k]);
                k = path[k];
            }//若前一节点不为起点则不断查询前一节点
            printf("%s 价格为: %d", name[start], distance[i]);
            printf("\n");

        } else {
            printf("%s不能到达", name[i]);
            printf("\n");
        }
    }
}

//主函数起到遍历初始值的效果
int main() {
    //开始时进行初始化遍历
    for (int m = 0; m < 20; ++m) {
        start = m;
        printf("%s为起点\n", name[m]);
        for (int i = 0; i < N; i++) {
            path[i] = -1;//一开始所有点的前一点为起点
            is[i] = 0;//都未选用
            distance[i] = destination[start][i];//初始时路程都为起点道该点距离
        }
        is[start] = 1;//第一个节点选用
        find();
        showpath();
    }

}