#include <stdio.h>
//假设取10个节点，N=28
//定义无穷大为100000
#define N 20
int distance[N];//最短路径
int path[N];//上一节点
int is[N];//是否选用该节点,0位未选用
int start;
int destination[N][N] = {
        {10000, 75,    10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000},
        {55,    10000, 15,    10000, 100,   10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000},
        {10000, 45,    10000, 75,    15,    10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000},
        {10000, 10000, 75,    10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000},
        {10000, 100,   35,    10000, 10000, 110,   135,   10000, 10000, 10000, 10000, 10000, 10000, 75,    10000, 10000, 10000, 10000, 10000, 10000},
        {10000, 10000, 10000, 10000, 110,   10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000},
        {10000, 10000, 10000, 10000, 225,   10000, 185,   65,    10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000},
        {10000, 10000, 10000, 10000, 10000, 10000, 125,   10000, 45,    10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 45},
        {10000, 10000, 10000, 10000, 10000, 10000, 35,    75,    10000, 45,    35,    10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000},
        {10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 55,    10000, 35,    10000, 10000, 45,    10000, 10000, 10000, 10000, 10000, 10000},
        {10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 35,    25,    10000, 25,    10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000},
        {10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 25,    10000, 25,    10000, 10000, 10000, 10000, 10000, 10000, 10000},
        {10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 25,    10000, 25,    15,    10000, 10000, 10000, 10000, 10000},
        {10000, 10000, 10000, 75,    10000, 10000, 10000, 10000, 10000, 45,    10000, 10000, 45,    10000, 10000, 10000, 10000, 10000, 10000, 10000},
        {10000, 10000, 25,    10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 25,    10000, 10000, 15,    15,    10000, 10000, 10000},
        {10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 25,    10000, 15,    10000, 10000, 10000},
        {10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 15,    15,    10000, 15,    10000, 10000},
        {10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 35,    10000, 55,    10000},
        {10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 55,    10000, 10000},
        {10000, 10000, 10000, 10000, 10000, 10000, 10000, 45,    10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000}

};//路程矩阵
//find函数寻找最短路径
void find() {
    //最多进行N-1次循环
    for (int k = 1; k < N; k++) {
        double max = 10000;//路径最大值
        int u = 0;//u为已经找到最短路径的节点,初始状态都为起点0
        for (int i = 0; i < N; i++) {
            if (is[i] == 0 && distance[i] <= max) {
                u = i;
                max = distance[i];
            }
        }
        is[u] = 1;
        //找出一点后更新其余点的最短路径
        for (int y = 0; y < N; y++) {
            if (is[y] == 0 && distance[u] + destination[u][y] < distance[y]) {
                distance[y] = distance[u] + destination[u][y];
                path[y] = u;
            }
        }
    }
}

//输出最短路径
void showpath() {
    int count = 1, count1 = 1;
    for (int i = 1; i < N; i++) {
        if (is[i] == 1) {
            int k = i;

            //输出到第一个结点
            if (start != 0 && start != 1) {
                if (count == 1) {
                    while (k != -1) {
                        printf("0<-%d<-", k);
                        k = path[k];
                    }//若前一节点不为起点则不断查询前一节点
                    printf("%d 价格为: %d", start, distance[i]);
                    printf("\n");
                    count++;
                }
            }
            if (start == 1 && count1 == 1) {
                printf("0<-");
                printf("%d 价格为: 55", start);
                printf("\n");
                count1++;
            }

            k = i;
            while (k != -1) {
                printf("%d<-", k);
                k = path[k];
            }//若前一节点不为起点则不断查询前一节点
            printf("%d 价格为: %d", start, distance[i]);
            printf("\n");

        } else {
            printf("%d不能到达", i);
            printf("\n");
        }
    }
}

//主函数起到遍历初始值的效果
int main() {
    //开始时进行初始化遍历
    start = 1;
    for (int i = 0; i < N; i++) {
        path[i] = -1;//一开始所有点的前一点为起点
        is[i] = 0;//都未选用
        distance[i] = destination[start][i];//初始时路程都为起点道该点距离
    }
    is[start] = 1;//第一个节点选用
    find();
    showpath();
}